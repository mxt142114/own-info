<!DOCTYPE html>
<html>
<head>
<title>react-hooks.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h2 id="%E5%BC%95%E8%A8%80">引言</h2>
<p><code>React Hooks</code> 是 <code>React 16.7.0-alpha</code> 版本推出的新特性，React16.8中加入了Hooks，让React函数式组件再一次升华，那么到底什么是Hooks？</p>
<p><code>React官网</code>和<code>2018年的React conf</code>上都提到了动机这个东西，那么出现hooks的动机是什么？是什么推动了hooks的出现？先来看一下Hooks的动机。</p>
<h4 id="1-%E5%9C%A8%E7%BB%84%E4%BB%B6%E9%97%B4%E5%A4%8D%E7%94%A8%E7%8A%B6%E6%80%81%E9%80%BB%E8%BE%91%E5%BE%88%E9%9A%BE">1. 在组件间复用状态逻辑很难</h4>
<p>React没有提供可复用性行为“附加”到组件的途径，在写类组件的时候，一个类是一个闭包并且state在组件间传递并不怎么友好，虽然可以使用props和高阶组件来解决，但是这样会组件的结构更麻烦。如果你在 React DevTools 中观察过 React 应用，你会发现由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。</p>
<h4 id="2-%E5%A4%8D%E6%9D%82%E7%BB%84%E4%BB%B6%E5%8F%98%E5%BE%97%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3">2. 复杂组件变得难以理解</h4>
<p>React中的类组件是很重的，比如说我就想实现一个非常简单的功能，必须要带一堆钩子函数，让一个简单的组件变得很复杂。而且由于不同的生命周期在不同的阶段调用，导致我们会在相应的地方作一些处理，有可能把一些完全不相干的代码因为执行周期相同必须放在同一个生命周期中，很容易引发bug。</p>
<h2 id="react-hooks%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">React Hooks是什么？</h2>
<p>Hooks英文翻译为钩子，顾名思义为React的钩子函数的概念。在函数组件中把React的状态和生命周期等这些特性钩入进入，这就是React的Hook。</p>
<h2 id="hooks%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">Hooks使用场景</h2>
<p>Hook就是一个函数，但是又两个规则：</p>
<ol>
<li>只能在函数的最外层调用hook。不要在循环、条件判断或者子函数中调用。</li>
<li>只能在React的函数组件中调用Hook。不能再class类调用hooks</li>
</ol>
<p>示例</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> classnames <span class="hljs-keyword">from</span> <span class="hljs-string">'classnames'</span>
<span class="hljs-keyword">import</span> { Toast } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components'</span>
<span class="hljs-keyword">import</span> { sendCode, sendAuthCode, sendCodeVer } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/api/login'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./style.scss'</span>


<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props)
        <span class="hljs-keyword">this</span>.state = {
            <span class="hljs-attr">second</span>: <span class="hljs-string">'获取验证码'</span>,
            <span class="hljs-attr">countdownDisabled</span>: !(<span class="hljs-regexp">/^1[\d]{10}$/g</span>).test(<span class="hljs-keyword">this</span>.props.mobile),
            <span class="hljs-attr">disabled</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">isSendMsg</span>: <span class="hljs-literal">false</span>
        }
        <span class="hljs-keyword">this</span>.second = <span class="hljs-number">60</span>
    }

    getVcode = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> { mobile, type } = <span class="hljs-keyword">this</span>.props
        <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">disabled</span>: <span class="hljs-literal">true</span> })
        <span class="hljs-keyword">let</span> ajax = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">'hospital'</span>) { <span class="hljs-comment">// 医院客服使用后台</span>
            ajax = sendAuthCode({ mobile })
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">'privacy'</span>) { <span class="hljs-comment">// 隐私密码获取验证码</span>
            ajax = sendCodeVer()
        } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 通用</span>
            ajax = sendCode({ mobile })
        }

        ajax.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
            <span class="hljs-keyword">const</span> data = res.data
            <span class="hljs-keyword">if</span> (data.status == <span class="hljs-number">200</span> || data.isSuccess) {
                Toast(<span class="hljs-string">'验证码已发送'</span>)
                <span class="hljs-keyword">this</span>.countdown()
            } <span class="hljs-keyword">else</span> {
                Toast(data.msg || data.message || <span class="hljs-string">'发送失败'</span>)
            }
        }).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
            Toast(<span class="hljs-string">'发送失败'</span>)
        }).finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">disabled</span>: <span class="hljs-literal">false</span> }))
    }

    <span class="hljs-comment">// 验证码倒计时</span>
    countdown = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">this</span>.setState({
            <span class="hljs-attr">isSendMsg</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">second</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.second}</span>s重新获取`</span>,
            <span class="hljs-attr">countdownDisabled</span>: <span class="hljs-literal">true</span>
        })
        <span class="hljs-keyword">this</span>.second--;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.second &gt; <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">let</span> timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                clearTimeout(timer)
                <span class="hljs-keyword">this</span>.countdown()
            }, <span class="hljs-number">1000</span>)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.second = <span class="hljs-number">60</span>
            <span class="hljs-keyword">this</span>.setState({
                <span class="hljs-attr">second</span>: <span class="hljs-string">'重新获取'</span>,
                <span class="hljs-attr">countdownDisabled</span>: (<span class="hljs-regexp">/^1[\d]{10}$/g</span>).test(<span class="hljs-keyword">this</span>.props.mobile) ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>,
                <span class="hljs-attr">isSendMsg</span>: <span class="hljs-literal">false</span>
            })
        }
    }

    componentWillReceiveProps(pre) {
        <span class="hljs-keyword">this</span>.setState({
            <span class="hljs-attr">countdownDisabled</span>: (<span class="hljs-regexp">/^1[\d]{10}$/g</span>).test(pre.mobile) &amp;&amp; !<span class="hljs-keyword">this</span>.state.isSendMsg ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>
        })
    }

    render() {
        <span class="hljs-keyword">const</span> { countdownDisabled, second, disabled } = <span class="hljs-keyword">this</span>.state
        <span class="hljs-keyword">const</span> { className } = <span class="hljs-keyword">this</span>.props

        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
                <span class="hljs-attr">className</span>=<span class="hljs-string">{classnames(</span>'<span class="hljs-attr">panda-countdown-btn</span>', <span class="hljs-attr">className</span>, { <span class="hljs-attr">active:</span> <span class="hljs-attr">countdownDisabled</span> })}
                <span class="hljs-attr">disabled</span>=<span class="hljs-string">{countdownDisabled</span> || <span class="hljs-attr">disabled</span>}
                <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.getVcode}</span>
            &gt;</span>{second}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
        )
    }
}
</div></code></pre>
<p>如果使用React Hooks我们可以这么写：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> classnames <span class="hljs-keyword">from</span> <span class="hljs-string">'classnames'</span>
<span class="hljs-keyword">import</span> { isMobile } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/reg'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./style.scss'</span>


<span class="hljs-keyword">const</span> getCode = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> res({ <span class="hljs-attr">code</span>: <span class="hljs-number">200</span> }), <span class="hljs-number">300</span>)
    })
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {
    <span class="hljs-keyword">const</span> { className, mobile } = props
    <span class="hljs-keyword">const</span> [second, setSecond] = useState(<span class="hljs-string">'获取验证码'</span>)
    <span class="hljs-keyword">const</span> [disabled, setDisabled] = useState(<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">const</span> [isSend, clickSend] = useState(<span class="hljs-literal">false</span>)
    <span class="hljs-keyword">let</span> secondTime = <span class="hljs-number">60</span>

    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        setDisabled(!isMobile(mobile)) <span class="hljs-comment">// 根据手机号判断是否可以发送验证码</span>
    }, [mobile])

    <span class="hljs-keyword">const</span> getVcode = <span class="hljs-keyword">async</span> () =&gt; {
        setDisabled(<span class="hljs-literal">true</span>)
        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> getCode()
        <span class="hljs-keyword">if</span> (res.code == <span class="hljs-number">200</span>) {
            clickSend(<span class="hljs-literal">true</span>)
            countdown()
        }
        setDisabled(<span class="hljs-literal">false</span>)
    }

    <span class="hljs-comment">// 验证码倒计时</span>
    <span class="hljs-keyword">const</span> countdown = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        setSecond(<span class="hljs-string">`<span class="hljs-subst">${secondTime}</span>s重新获取`</span>)
        setDisabled(<span class="hljs-literal">true</span>)
        secondTime--

        <span class="hljs-keyword">if</span> (secondTime &gt; <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">let</span> timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                clearTimeout(timer)
                countdown()
            }, <span class="hljs-number">1000</span>)
        } <span class="hljs-keyword">else</span> {
            secondTime = <span class="hljs-number">60</span>
            setSecond(<span class="hljs-string">'重新获取'</span>)
            setDisabled(<span class="hljs-literal">false</span>)
            clickSend(<span class="hljs-literal">false</span>)
        }
    }

    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
            <span class="hljs-attr">className</span>=<span class="hljs-string">{classnames(</span>'<span class="hljs-attr">components-countdown</span>', <span class="hljs-attr">className</span>)}
            <span class="hljs-attr">onClick</span>=<span class="hljs-string">{getVcode}</span>
            <span class="hljs-attr">disabled</span>=<span class="hljs-string">{isSend</span> || <span class="hljs-attr">disabled</span>}
        &gt;</span>{second}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
    )
}
</div></code></pre>
<p>通过上面两种写法，很明显Hooks的写法更加简洁明了，通过纯函数组件和可控的数据流来实现状态到view层的展示。</p>
<h2 id="hooks%E7%9A%84%E4%BC%98%E7%82%B9">Hooks的优点</h2>
<ol>
<li>使用hooks，如果业务变更，就不需要把函数组件修改成类组件。</li>
<li>告别了繁杂的this和合并了难以记忆的生命周期。</li>
<li>支持包装自己的Hooks(自定义Hooks)。</li>
<li>更好的完成状态之间的共享，解决原来class组件内部封装的问题，也解决了高阶组件和函数组件的嵌套过深。一个组件一个自己的state，一个组件内可以公用。</li>
</ol>
<h2 id="hook%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95">Hook内置方法</h2>
<ul>
<li>useState</li>
<li>useEffect</li>
<li>useContext</li>
<li>useReducer</li>
<li>useCallback</li>
<li>useMemo</li>
<li>useRef</li>
<li>useImperativeHandle</li>
<li>useLayoutEffect</li>
</ul>
<h4 id="usestate">useState</h4>
<p>以前的函数式组件被成为纯函数组件或者无状态组件，是只能接受父组件传来的props并且只能做展示功能，没有自己的state状态与对应的生命周期。</p>
<p>现在State Hooks可以让函数组件有状态与生命周期。</p>
<p>useState是React一个内置Hook，他本身接收一个值为默认状态值，函数执行返回一个数组，第一个参数为状态，第二个值为改变状态的方法。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count - 1)}&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</div></code></pre>
<h4 id="useeffect">useEffect</h4>
<p><code>useEffect</code>是处理各种状态变更后的一些副作用，只有再特定的时间才会执行。</p>
<p>一个至关重要的 Hooks API，<code>useEffect</code>用于处理各种状态变化造成的副作用，也就是说只有在特定的时刻，才会执行的逻辑。</p>
<p><code>useEffect</code>这个方法传入一个函数作为参数，在函数里面执行副作用代码，并且useEffec的第一个参数还支持返回值为一个函数，这个函数执行相当于组件更新和卸载。第二个参数为deep</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// =&gt; componentDidMount/componentDidUpdate</span>
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// update </span>
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">${count}</span> times`</span>;
    <span class="hljs-comment">// =&gt; componentWillUnMount</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanup</span>(<span class="hljs-params"></span>) </span>{
    	<span class="hljs-built_in">document</span>.title = <span class="hljs-string">'app'</span>;
    }
  }, [count]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked {count} times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;
        Click me
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</div></code></pre>
<p>如果deep为空时每次状态更新都会执行第一个callback, 当deep为一个<code>[]</code>时相当于<code>componentDidMount</code>指挥执行一次，当deep为一个或者多个<code>[count]</code>是时候类似于vue中的<code>watch</code></p>
<h4 id="usecontext">useContext</h4>
<p>context 是在外部 create ，内部 use 的 state，它和全局变量的区别在于，如果多个组件同时 useContext，那么这些组件都会 rerender，如果多个组件同时 useState 同一个全局变量，则只有触发 setState 的当前组件 rerender。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useState, useContext, createContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-comment">// 1. 使用 createContext 创建上下文</span>
<span class="hljs-keyword">const</span> UserContext = <span class="hljs-keyword">new</span> createContext();

<span class="hljs-comment">// 2. 创建 Provider</span>
<span class="hljs-keyword">const</span> UserProvider = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {
  <span class="hljs-keyword">let</span> [username, handleChangeUsername] = useState(props.username || <span class="hljs-string">''</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">username</span>, <span class="hljs-attr">handleChangeUsername</span> }}&gt;</span>
      {props.children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">const</span> Pannel = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> { username, handleChangeUsername } = useContext(UserContext); <span class="hljs-comment">// 3. 使用 Context</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>user: {username}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> handleChangeUsername(e.target.value)} /&gt;
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
};

const Form = () =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Pannel</span> /&gt;</span>;

const App = () =&gt; (
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">UserProvider</span> <span class="hljs-attr">username</span>=<span class="hljs-string">"username"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Form</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">UserProvider</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
)
</span></div></code></pre>
<h4 id="usereducer">useReducer</h4>
<p>useReducer和useState几乎是一样的，需要外置外置 reducer (全局)，通过这种方式可以对多个状态同时进行控制。使用起来其实跟redux中的数据流的概念非常接近。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useState, useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'up'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span> };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'down'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.count - <span class="hljs-number">1</span> };
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, { <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> })
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {state.count}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'up' })}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'down' })}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</div></code></pre>
<h4 id="usecallback">useCallback</h4>
<p><code>useCallback</code>可认为对依赖项的监听，把接受一个回调函数和依赖项数组，返回一个该回调函数的memoized(记忆)版本，该回调函数仅在某个依赖项改变时才会更新。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useState, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">const</span> CallbackComponent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">let</span> [count, setCount] = useState(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">let</span> [num, setNum] = useState(<span class="hljs-number">1</span>);
    
    <span class="hljs-keyword">const</span> memoized = useCallback( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">return</span> num;
    },[count])
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"记忆："</span>,memoized());
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"原始："</span>,num);
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {setCount(count + 1)}}&gt; count+ <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {setNum(num + 1)}}&gt; num+ <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/&gt;</span>
    )
}
</span></div></code></pre>
<h4 id="usememo">useMemo</h4>
<p><code>useMemo</code> 主要用于渲染过程优化，两个参数依次是计算函数（通常是组件函数）和依赖状态列表，当依赖的状态发生改变时，才会触发计算函数的执行。如果没有指定依赖，则每一次渲染过程都会执行该计算函数。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useState, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Time</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{Date.now()}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);
  
  <span class="hljs-keyword">const</span> memoizedChildComponent = useMemo(<span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Time</span> /&gt;</span>;
  }, [count]);

  return (
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{memoizedChildComponent}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
}
</span></div></code></pre>
<h4 id="useref">useRef</h4>
<p><code>useRef</code> 返回一个可变的 ref 对象，.current 属性初始化为传递的参数（initialValue）。返回的对象将持续整个组件的生命周期。事实上 useRef 是一个非常有用的 API，许多情况下，我们需要保存一些改变的东西，它会派上大用场的。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useRef, useImperativeHandle } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">props, ref</span>) </span>{
    <span class="hljs-keyword">const</span> inputRef = useRef();
    useImperativeHandle(ref, () =&gt; ({
        <span class="hljs-attr">focus</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            inputRef.current.value=<span class="hljs-string">"Hello"</span>;
        }
    }));
    
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span> /&gt;</span>;
}
</span></div></code></pre>
<h4 id="useimperativehandle">useImperativeHandle</h4>
<p>当我们使用父组件把ref传递给子组件的时候，这个Hook允许在子组件中把自定义实例附加到父组件传过来的ref上，有利于父组件控制子组件。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useRef, useImperativeHandle } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">props, ref</span>) </span>{
    <span class="hljs-keyword">const</span> inputRef = useRef();
    useImperativeHandle(ref, () =&gt; ({
        <span class="hljs-attr">focus</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            inputRef.current.value=<span class="hljs-string">"Hello"</span>;
        }
    }));

    <span class="hljs-keyword">return</span> &lt;input ref={inputRef} /&gt;;
}

const ChildList = forwardRef(Child);

const Parent = () =&gt; {
    let ref = useRef(null);
    useEffect(() =&gt; {
        console.log(ref);
        ref.current.focus();
    })

    return &lt;ChildList ref={ref}/&gt;
}
export default Parent
</div></code></pre>
<h3 id="uselayouteffect">useLayoutEffect</h3>
<p>这个是用在处理DOM的时候,当你的useEffect里面的操作需要处理DOM,并且会改变页面的样式,就需要用这个,否则可能会出现出现闪屏问题, useLayoutEffect里面的callback函数会在DOM更新完成后立即执行,但是会在浏览器进行任何绘制之前运行完成,阻塞了浏览器的绘制</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useRef, useEffect, useLayoutEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">const</span> Wewe = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> ref1 = useRef(<span class="hljs-literal">null</span>)
    useLayoutEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        ref1.current.style.margin = <span class="hljs-string">'15px'</span>
    }, [])
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref1}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{width:</span> <span class="hljs-attr">200</span>, <span class="hljs-attr">height:</span> <span class="hljs-attr">200</span>, <span class="hljs-attr">background:</span> '<span class="hljs-attr">red</span>'}}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
}
</div></code></pre>
<h2 id="%E5%9F%BA%E4%BA%8Ehooks%EF%BC%8C%E5%A2%9E%E5%BC%BAhooks">基于Hooks，增强hooks</h2>
<p>由于每一个 Hooks API 都是纯函数的概念，使用时更关注输入 (input) 和输出 (output)，因此可以更好的通过组装函数的方式，对不同特性的基础Hooks API进行二次封装，得到更丰富的Hooks</p>
<h4 id="usedidmount">useDidMount</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">const</span> useDidMount = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fn &amp;&amp; fn(), [])
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useDidMount;
</div></code></pre>
<h4 id="usedidupdate">useDidUpdate</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> useDidUpdate = <span class="hljs-function">(<span class="hljs-params">fn, conditions</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> didMoutRef = useRef(<span class="hljs-literal">false</span>);
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!didMoutRef.current) {
      didMoutRef.current = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">return</span> fn &amp;&amp; fn();
  }, conditions);
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useDidUpdate
</div></code></pre>
<h4 id="usewillunmount">useWillUnmount</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> useWillUnmount = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fn &amp;&amp; fn(), []);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useWillUnmount;

</div></code></pre>
<h4 id="usefield">useField</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> useField = <span class="hljs-function">(<span class="hljs-params">initial</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> [value, <span class="hljs-keyword">set</span>] = useState(initial);

  return {
    value,
    <span class="hljs-keyword">set</span>,
    reset: () =&gt; <span class="hljs-keyword">set</span>(initial),
    bind: {
      value,
      <span class="hljs-attr">onChange</span>: <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-keyword">set</span>(e.target.value),
    },
  };
}

export default useField;
</div></code></pre>
<h4 id="useonlinestate">useOnlineState</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>


<span class="hljs-keyword">const</span> useOnlineStatus = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [online, <span class="hljs-keyword">set</span>] = useState(navigator.onLine)

  const handleOnline = () =&gt; <span class="hljs-keyword">set</span>(true)
  const handleOffline = () =&gt; <span class="hljs-keyword">set</span>(false)

  useEffect(() =&gt; {
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'online'</span>, handleOnline)
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'offline'</span>, handleOffline)
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'online'</span>, handleOnline)
      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'offline'</span>, handleOffline)
    }
  }, [])
  <span class="hljs-keyword">return</span> {
    online,
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useOnlineStatus
</div></code></pre>
<h4 id="usetouch">useTouch</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">const</span> useTouch = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [touched, <span class="hljs-keyword">set</span>] = useState(false)
  return {
    touched,
    <span class="hljs-attr">bind</span>: {
      <span class="hljs-attr">onTouchStart</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">set</span>(true),
      onTouchEnd: () =&gt; <span class="hljs-keyword">set</span>(false),
    },
  }
}

export default useTouch
</div></code></pre>
<h4 id="useinputvalue">useInputValue</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { useState, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useInputValue</span>(<span class="hljs-params">initValue</span>) </span>{
    <span class="hljs-keyword">const</span> [value, setValue] = useState(initValue)

    <span class="hljs-keyword">const</span> onChange = useCallback(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
        setValue(e.currentTarget.value)
    }, [])

    <span class="hljs-keyword">return</span> {
        value,
        onChange
    }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useInputValue
</div></code></pre>
<p>我们对组件增强时，组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同，因此大部分场景，我们需要利用 useCallback 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。</p>
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h2>
<ul>
<li><a href="https://reactjs.org/docs/hooks-reference.html">hooks-reference</a></li>
<li><a href="https://github.com/beizhedenglong/react-hooks-lib">react-hooks-lib</a></li>
</ul>

</body>
</html>
